{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Testify","text":"<p>This documentation has been developed to help you understand what Testify is used for.</p>"},{"location":"#what-is-testify","title":"What is Testify?","text":"<p>Testify is an open-source generic framework used for the testing of Object Request Brokers (ORBs). It is based on an Apache Yoko fork, originally built for OpenLiberty. </p>"},{"location":"#what-is-an-orb","title":"What is an Orb?","text":"<p>An ORB is a middleware which allows program calls to be made from one computer to another via a computer network. </p>"},{"location":"#what-is-yoko","title":"What is Yoko?","text":"<p>Yoko is an open-source project maintained by IBM, and is an implementation of an ORB system to carry out interprocess communication. </p> <p>The diagram below displays how Testify works with Yoko:</p> <p></p>"},{"location":"pages/jul-logging/","title":"Enabling J.U.L Logging","text":"<p>A Logger object is used to log messages for a particular system or application component. In other words, it is a means of tracking events that happen when some software runs by capturing and persisting important data and making it available for analysis at any point in time. </p>"},{"location":"pages/jul-logging/#why-is-logging-used","title":"Why is Logging Used?","text":"<p>To see what is happening within a system, we must use <code>@Logging</code>to allow tracing, which can be found in the <code>@Logging</code> annotation, in the jupiter package. When a class or test method has the <code>@Logging</code> annotation, the <code>specified java.util.logging</code>is enabled for it.</p> <p>Since other logging frameworks (Log4J, SLF4J) are j.u.l-compatible, these should work for them, but have not been tested. </p> <p>Upon turning on logging and running tests, all logging is collected and printed out - logging up to where the test began and after the test is run. Testify captures any enabled logging into a buffer, and flushes the buffer to the console - before and after a test. </p>"},{"location":"pages/jul-logging/#formatting","title":"Formatting","text":"<p>There are various different formatting options that are used for logging. Testify tells us how many threads are involved in logging while your tests are running.</p> <p>Testify prints a key to threads and gives them easily distinguishable nicknames (AAA, BBB, etc) - each with their own unique ID\u2019s.</p> <p>Instead of timestamps with each logging statement, Testify computes and prints elapsed time which tells us how long into the test we are. This is simply because it is the most helpful when comparing the behaviour between two tests to see which test takes longer to reach a certain point, easing the diagnosis of a potential problem.</p> <p>Looking at the thread key, we can see that there is only one thread involved on the client. Testify does not have remote part logging implemented yet, so you will not get any trace from the server. The eventual idea is that we collect trace from the server.</p>"},{"location":"pages/testify-guide/","title":"Implementing Testify to a RMI Java Application","text":"<p>This guide will explain and allow you to implement Testify to a Remote Method Invocation (RMI) application.</p>"},{"location":"pages/testify-guide/#steps-to-build-testify","title":"Steps to build Testify","text":"<ol> <li> <p>Clone the following Yoko repository and go to the directory RMI in the root directory of the repository.</p> <pre><code>git clone https://github.com/Testibus-Team4/yoko.git\ncd yoko\n</code></pre> </li> <li> <p>Navigate to <code>RMI_Demo/start</code> directory using the interface of your chosen IDE and also in the terminal using the command folowing command from the yoko directory.</p> <pre><code>cd RMI_Demo/start\n</code></pre> </li> <li> <p>Find the <code>build.gradle</code> within that repository, and add the following code to the dependencies section of the file:</p> <pre><code>testImplementation 'org.apache.yoko:yoko-testify:1.5.0.9cce293956'\n</code></pre> <p>Your build.gradle file should now look like this:</p> <pre><code>dependencies {\n    testImplementation 'org.apache.yoko:yoko-testify:1.5.0.9cce293956'\n    testImplementation 'org.junit.jupiter:junit-jupiter:5.8.2'\n    testRuntimeOnly 'org.junit.platform:junit-platform-runner:1.8.2'\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.2'\n}\n</code></pre> <p>The dependency will be added to the project and the Testify library will be available for use.</p> </li> <li> <p>Refresh the <code>build.gradle</code> dependencies using the following command:</p> <pre><code>gradle --refresh-dependencies\n</code></pre> </li> <li> <p>Navigate to <code>/src/test/java/com/acme/hello/InitialTest.java</code> using your IDE interface. This is the file that will contain the tests.</p> </li> <li> <p>Add the following imports into <code>IntitialTest.java</code>:</p> <pre><code>import testify.bus.Bus;\nimport testify.bus.key.TypeKey;\nimport testify.jupiter.annotation.ConfigurePartRunner;\nimport testify.parts.PartRunner;\n</code></pre> </li> <li> <p>Next lets add the annotation to the <code>InitialTest.java</code> class. Do this by adding the following code above the class declaration:</p> <pre><code>@ConfigurePartRunner(PartRunner.class)\n</code></pre> </li> <li> <p>Now lets expand the setup method to include the following code:</p> <pre><code>@BeforeAll\nstatic void setup(PartRunner runner) {\n    // When forking use new Java Virtual Machine\n    runner.useNewJVMWhenForking();\n    // Create a new part called HelloServer\n    runner.fork(\"HelloServer\",\n            // Tell Testify how to start this new part\n            InitialTest::runServer,\n            // Tell Testify how to stop this part\n            bus -&gt; bus\n                    // Send a stp request\n                    .put(STOP_REQUESTED, 0)\n                    // Wait for stopped server response\n                    .get(SERVER_STOPPED));\n    // Wait for the server to start\n    port = runner.bus(\"HelloServer\").get(SERVER_STARTED);\n    lookupURL = \"//localhost:\" + port + \"/MessengerService\";\n    System.out.println(lookupURL);\n}\n</code></pre> </li> <li> <p>The above code will call on the <code>PartRunner</code> parameter. This allows us to use the methods within part runner and call on and use <code>useNewJVMWhenForking()</code> and also <code>fork()</code>. <code>useNewJVMWhenForking()</code> name means to use a new Java Virtual Machine every time something is forked. <code>fork()</code> calls upon the <code>runServer()</code> method.</p> <pre><code>// This method runs in the server process\nprivate static void runServer(Bus bus) {\n    logging();\n    int port = HelloServer.start(0);\n    // Notify the test process that the server has now started on a particular port\n    bus.put(SERVER_STARTED, port);\n    System.out.println(port);\n    // Get STOP_REQUESTED event from the bus\n    bus.get(STOP_REQUESTED);\n    // call stop method from HelloServer class\n    HelloServer.stop();\n    // Send SERVER_STOPPED event and port back to the client\n    bus.put(SERVER_STOPPED, port);\n}\n</code></pre> <p>Also; now you can go ahead and remove the call for <code>logging()</code> from the <code>testHello()</code> method. This is because you have now called it in the <code>runServer()</code> method.</p> <p>The above code will call on the <code>Bus</code> parameter. This allows us to use the methods within the bus and call on and use <code>put()</code> and also <code>get()</code>. <code>put()</code> will put the <code>SERVER_STARTED</code> event and the port number on the bus. <code>get()</code> will get the <code>STOP_REQUESTED</code> event from the bus. This allows the client and server communicate with each other with more detail. Using Bus also allows us to know how long a server takes to start, when the client starts to interact with the server and also when the server shuts down.</p> </li> <li> <p>Since you are now able to send events and messages between the client and server; you can send the port across too. This means you can go ahead and replace:</p> <pre><code>    static int port = 1099;\n</code></pre> <p>with:</p> <pre><code>    static int port;\n</code></pre> </li> <li> <p>You are now ready to build your application using gradle and see how Testify has helped testing. In the start` repository, run either of following commands:</p> <ul> <li> <p>To build with tests use:</p> <pre><code>./gradlew build\n</code></pre> </li> <li> <p>To build without tests use:</p> <pre><code>./gradlew build -x test\n</code></pre> </li> </ul> </li> </ol>"},{"location":"pages/testify-guide/#how-testify-works-in-initialtestjava","title":"How Testify works in InitialTest.java","text":"<pre><code>    import testify.bus.Bus;\n    import testify.bus.key.TypeKey;\n    import testify.jupiter.annotation.ConfigurePartRunner;\n    import testify.parts.PartRunner;\n</code></pre> <p>These imports enable Testify in your testing. The annotation you are using from Testify is <code>@ConfigurePartRunner</code>. This annotation allows us to make use of <code>runner.useNewJVMWhenForking()</code> and <code>runner.fork()</code>. These runners allow you to run methods from your app/project within the testing. The <code>@ConfigurePartRunner</code>annotation is further explained in the ConfigurePartRunner section.</p> <p>In <code>IntitialTest.java</code> the tests are sending and getting events from methods using the bus. Thanks to these events you are making sure that a new instruction is not run until the previous one complete and the correct values are shared across processes/threads. This is done using TypeSpecs which are Testify specific. TypeSpecs are enums that you can call. In this case these are the events. Thanks to these TypeSpecs you are able to know:</p> <ul> <li>How long a server took to start (SERVER_STARTED)</li> <li>When the client starts to interact with the server</li> <li>When the server can shut down (STOP_REQUESTED)</li> <li>When the server shut down (SERVER_STOPPED)</li> </ul> <p>This is all done in the <code>setup()</code> method which also is annotated using <code>@BeforeAll</code> - this means that nothing will happen until this method is completed. The most important method is <code>runServer()</code> which takes in bus as a parameter. In this method everything is declared and then passed to the <code>setup()</code> method inside the <code>runner.fork()</code> method as a parameter.</p>"},{"location":"pages/annotations/annotations/","title":"Extending Annotations","text":"<p>Annotations are a form of metadata, which are used to provide data about a program that is not part of the program itself. They are a very generic tool and can be used for anything that processes the code before its run. </p> <p>The Annotation system in Java is extensible, as you can create your own annotations with their own meanings. You can also tell the compiler where these annotations go. </p>"},{"location":"pages/annotations/annotations/#examples","title":"Examples","text":"<p>There are several annotations that are provided by JUnit. Some examples are:</p> <ul> <li>@Test : this labels a method as a test, so JUnit goes through all of the compiled code looking for anything that has the same annotation and runs it.</li> <li>@BeforeAll : this is used to show that the method should be excuted before all tests in the current test class.</li> <li>@Override : this is used to indicate to the compiler that the subclasss method is overriding the superclass method.</li> </ul> <p>These examples have been included in the documentation to provide an insight into the use and effects of annotations.</p>"},{"location":"pages/annotations/annotations/#jupiter","title":"Jupiter","text":"<p>Jupiter adds a whole extra level of functionality to annotations because when it looks at a class, it does extra work to help users better comprehend what is happening. Jupiter looks at the annotations used and considers any relevant annotations used on them as if they were on the same class.</p>"},{"location":"pages/annotations/annotations/#annotations-within-testify","title":"Annotations Within Testify","text":"<p>Testify provides some annotations, two of which are:</p> <ul> <li> <p>@ConfigurePartRunner</p> <p>The <code>@ConfigurePartRunner</code> annotation allows you to get a part runner in your setup and your test methods. Having the <code>@ConfigurePartRunner</code> annotation is simply a shorthand for including <code>@ExtendWith(PartRunnerExtension.class)</code> without making that class available. This essentially tells JUnit to load up the <code>PartRunnerExtension</code> upon running the class, and to use any extension points that are in this class in the course of running any tests. The <code>@ConfigurePartRunner</code>annotation is further explained in the ConfigurePartRunner section.</p> </li> <li> <p>@RetriedTest</p> <p>The <code>@RetriedTest</code> annotation labels the method as a test which can be run multiple times until at least one failure occurs. In other words, if at first you do succeed, try until you fail. This allows for tests that are programmatically aborted (e.g. by a failing assumption). If the total number of runs is reached without any successes or failures occurring, no further tests will be run. If there are any successess or failures, the total number of allowed aborted tests increases significantly.</p> </li> </ul> <p>By creating your own annotations in accordance with the JUnit5 Extension Model, Testify can be extended. If you are finding that you are doing the same things over and over again in your tests, create your own annotation.</p>"},{"location":"pages/annotations/part-runner/","title":"How to use @ConfigurePartRunner","text":"<p>We can use PartRunner as a parameter in test methods. The runner allows to us to fork methods onto another thread or JVM (Java Virtual Machine). </p> <p>PartRunner also allows us to use the bus to communicate with the parts of the program that have been forked. This allows for a lot more detail to be passed from the remote process to the test cases.</p>"},{"location":"pages/annotations/part-runner/#how-to-use-partrunner","title":"How to use PartRunner","text":"<ul> <li> <p>Use a new JVM when forking:</p> <pre><code>runner.useNewJVMWhenForking\n</code></pre> </li> <li> <p>Use a new thread when forking</p> <pre><code>runner.fork()\n</code></pre> </li> </ul> <p>Below is a code example of using the <code>@ConfigurePartRunner</code> annotation:</p> <pre><code>    @ConfigurePartRunner\n    public class InitialTest {\n        static int port;\n        private static String lookupURL;\n\n        @BeforeAll\n        static void setup(PartRunner runner) {\n            // When forking use new Java Virtual Machine\n            runner.useNewJVMWhenForking();\n            // Create a new part called HelloServer\n            runner.fork(\"HelloServer\",\n                    // Tell Testify how to start this new part\n                    InitialTest::runServer,\n                    // Tell Testify how to stop this part\n                    bus -&gt; bus\n                            // Send a stp request\n                            .put(STOP_REQUESTED, 0)\n                            // Wait for stopped server response\n                            .get(SERVER_STOPPED));\n            // Wait for the server to start\n            port = runner.bus(\"HelloServer\").get(SERVER_STARTED);\n            lookupURL = \"//localhost:\" + port + \"/MessengerService\";\n            System.out.println(lookupURL);\n        }\n    }\n</code></pre>"},{"location":"pages/bus/bus-concept/","title":"Bus Concept","text":""},{"location":"pages/bus/bus-concept/#what-is-the-bus-concept","title":"What is the Bus Concept?","text":"<p>The bus concept is used within Testify to help write JUnit tests for a test that is not single-threaded or on a single processor. The bus ensures effective communication between the different threads and processes for a specific test.</p>"},{"location":"pages/bus/bus-concept/#bus-vs-java-concurrency-synchronisation-utilities","title":"Bus vs Java Concurrency Synchronisation Utilities","text":"<p>The reason why the bus was created instead of using one of the many utilities that Java has for concurrency synchronisation is that the utilities Java has usually only works with multiple threads. However, Testify needs to be capable of working with multiple processes as well as multiple threads. This is why the bus concept was implemented within Testify.</p> <p></p>"},{"location":"pages/bus/bus-processes/","title":"Using the Bus across Threads and Sub Processes","text":""},{"location":"pages/bus/bus-processes/#simplebus","title":"SimpleBus","text":"<p>SimpleBus is the simple base interface for the bus that most processes that use the bus are based on.</p> Return Type Method Name Parameters Description SimpleBus put (String key, String value) This is similar to how put works on a Map. It puts a value on the bus for the matching key. After it has been put on the bus other threads and processes can access the value. String get (String key) Allows a thread or process to wait for a value to be put on the bus that matches the inputted key. Once it arrives on the bus the value is returned. SimpleBus onMsg (String key, Consumer&lt;String&gt; action) Performs the action inputted as a parameter once the value matching the inputted key arrives on the bus. You would use onMsg over get when you want to do something asynchronous with a value from the bus. boolean hasKey (String key) Returns true if the key inputted currently has a value on the bus. Bus forUser (String user) This is used if you only want a specific user to look at the value placed on the bus. String peek (String key) It returns the value from the key inputted if it currently exists on the bus. If there is no value then null is returned. Unlike <code>get</code> it does not wait for a value to be put on the bus."},{"location":"pages/bus/bus-processes/#userbus","title":"UserBus","text":"<p>UserBus has a similar interface to SimpleBus The main difference is that on the UserBus, the message you put and get from the bus is specific to a particular user. Within the UserBus interface, there is a <code>String user()</code> method which returns the name given to the user of the bus.</p>"},{"location":"pages/bus/bus-processes/#eventbus","title":"EventBus","text":"<p>EventBus is a more generic version of the SimpleBus, allowing us to no longer be restricted to just using strings on the bus. Oher then having a generic object type for the method, the rest of the interface is the same as SimpleBus. It also improves the SimpleBus by allowing you to have type safe key-value pairs.</p>"}]}